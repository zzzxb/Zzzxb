---
layout: post
title:  "聊聊最近"
date:   2022-05-14 19:48:00 +0800
categories: 设计模式
tag: 设计模式
---

* content
{:toc}

**迭代器模式**: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

## 示例

我们有下边两个对象， 分别用 数组、ArrayList 去存放数据, 当我们想要去遍历两个对象的时候需要加入一个遍历方法， 为了保持通用性，需要用一种方法可以让这两个对象用共同的方法去遍历， 这时就可以加入迭代器。

本例只演示了 Menu 如果加入迭代器， Menu1 同理。

* Menu

```java
public class Menu {
    private String[] args;
    private final int length = 16;
    private int foodNum = 0;

    public Menu() {
        args = new String[length];
    }

    public Menu(int len) {
        args = new String[len];
    }

    public void add(String dishes) {
        args[foodNum++] = dishes;
    }
    
    public String get(int i) {
        return i > length ? null : args[i];
    }

    public int length() {
        return foodNum;
    }
}
```

* Menu1

```java
public class Menu1 {
    private ArrayList<String> menu;

    public Menu1() {
        menu = new ArrayList<>();
    }

    public void add(String str) {
        menu.add(str);
    }
}
```

## 加入迭代器后

通过实现 `Iterator` 接口中的 `hashNext` 和 `next` 方法，来实现这个遍历器
当然如果没有并发问题的话也可以加入 `remove` 方法.

* MenuIterator

```java
public class MenuIterator implements Iterator<String> {
    private Menu menu;
    private int position = 0;

    public MenuIterator(Menu menu) {
        this.menu = menu;
    }

    @Override
    public boolean hasNext() {
        return null != menu.get(position);
    }

    @Override
    public String next() {
        return menu.get(position++);
    }
}
```
## 测试

下边展示的就是迭代器了相比直接改动 Menu 方法， 添加迭代器更有效也更简洁吧。

```java
public static void main(String[] args) {
    final Menu menu = new Menu();
    menu.add("a");
    menu.add("c");
    menu.add("d");
    menu.add("e");
    menu.add("f");

    // 这里也可以用 while 进行遍历，他的领域范围相比 for 更大, 下边循环领域范围只在他的循环体内有用， 这样可以减少不必要的麻烦，这是也是 Efffective Java 中比较推荐的
    for (final MenuIterator menuIterator = new MenuIterator(menu); menuIterator.hasNext();) {
        System.out.println(menuIterator.next());
    }
}
```
